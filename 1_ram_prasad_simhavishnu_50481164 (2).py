# -*- coding: utf-8 -*-
"""1_Ram_Prasad_Simhavishnu_50481164.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EM0XQfkOge3qksOsfwAVdMYf5FCJtBrC

Problem 1:
You need to implement the BFS algorithm for the bipartiteness test problem. An O(n + m)-time algorithm is suffice to pass any feasible test
cases.


---


(a) Input You need to read the input from the console. In the first line of the input, we have two positive integers n and m. n is the number of vertices in the graph and m is the number of edges in the graph. The vertices are indexed from 1 to n. You can assume that 1 ≤ n ≤ 1000 and 1 ≤ m ≤ 100000. In the next m lines, each line contains 2 integers: u and v. This indicates that there is an edge {u, v} in the graph. The input graph may not be connected.

(b) Output You need to output to the console. The output is either “yes” or “no”.
"""

from collections import deque

def checker(n, m, edges):
    graph = [[] for _ in range(n + 1)]
    for u, v in edges:
        graph[u].append(v)
        graph[v].append(u)

    a = [-1] * (n + 1)

    def bfs(start):
        queue = deque([start])
        a[start] = 0

        while queue:
            node = queue.popleft()
            for s in graph[node]:
                if a[s] == -1:
                    a[s] = 1 - a[node]
                    queue.append(s)
                elif a[s] == a[node]:
                    return False
        return True

    for i in range(1, n + 1):
        if a[i] == -1 and not bfs(i):
            return "no"
    return "yes"

n, m = map(int, input().split())
edges = [list(map(int, input().split())) for _ in range(m)]
print(checker(n, m, edges))